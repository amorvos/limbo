// Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, Rpc, axon, getRpcClient, rpc,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  axon = require('axon');

  rpc = require('axon-rpc');

  EventEmitter = require('events').EventEmitter;

  getRpcClient = function(dsn) {
    var client, req;
    req = axon.socket('req');
    client = new rpc.Client(req);
    req.connect.apply(req, arguments);
    return client;
  };

  Rpc = (function(superClass) {
    extend(Rpc, superClass);

    function Rpc(options) {
      var conn, group;
      conn = options.conn, group = options.group;
      if (!conn) {
        throw new Error('missing conn param in rpc provider options');
      }
      this._group = group;
      this._conn = conn;
      this.connect(conn);
    }

    Rpc.prototype.connect = function(dsn, callback) {
      var _bindMethods, group, self;
      if (callback == null) {
        callback = function() {};
      }
      this._client = getRpcClient(dsn);
      group = this._group;
      self = this;
      _bindMethods = function(methods) {
        var _group, _methods, fn, name, ref;
        if (methods == null) {
          methods = {};
        }
        fn = function(_methods) {
          var name1;
          self[name1 = _methods[0]] || (self[name1] = {});
          return self[_methods[0]][_methods[1]] = function() {
            var args, k, v;
            args = (function() {
              var results;
              results = [];
              for (k in arguments) {
                v = arguments[k];
                results.push(v);
              }
              return results;
            }).apply(this, arguments);
            args.unshift(_methods.join('.'));
            return self.call.apply(self, args);
          };
        };
        for (name in methods) {
          ref = name.split('.'), _group = ref[0], _methods = 2 <= ref.length ? slice.call(ref, 1) : [];
          if (_group !== group) {
            continue;
          }
          fn(_methods);
        }
        return self;
      };
      this.methods(function(err, methods) {
        _bindMethods(methods);
        self.emit('bind', err);
        return callback(err, methods);
      });
      return this;
    };

    Rpc.prototype.call = function(method) {
      method = this._group + "." + method;
      arguments[0] = method;
      return this._client.call.apply(this._client, arguments);
    };

    Rpc.prototype.methods = function() {
      return this._client.methods.apply(this._client, arguments);
    };

    return Rpc;

  })(EventEmitter);

  module.exports = Rpc;

}).call(this);
