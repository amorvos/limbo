// Generated by CoffeeScript 1.12.4
(function() {
  var EventEmitter, Mongo, axon, limbo, rpc,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  axon = require('axon-tls');

  rpc = require('axon-rpc');

  limbo = require('../limbo');

  EventEmitter = require('events').EventEmitter;

  Mongo = (function(superClass) {
    extend(Mongo, superClass);

    Mongo.prototype.getRpcServer = function(port, opt) {
      var rep;
      if (this.rpcServer) {
        return this.rpcServer;
      }
      rep = axon.socket('rep');
      return this.rpcServer = new rpc.Server(rep);
    };

    function Mongo(options) {
      var conn, group, methods, overwrites, rpcPort, schemas, statics;
      conn = options.conn, group = options.group, methods = options.methods, statics = options.statics, overwrites = options.overwrites, schemas = options.schemas, rpcPort = options.rpcPort;
      if (!conn) {
        throw new Error('missing conn param in mongo provider options');
      }
      this._group = group;
      this._conn = conn;
      this._methods = methods || {};
      this._statics = statics || {};
      this._overwrites = overwrites || {};
      this._rpcPort = rpcPort;
      this._schemas = {};
      this._models = {};
      this.loadSchemas(schemas);
    }

    Mongo.prototype.loadMethod = function(name, fn, schemas) {
      var key, ref, schema;
      this._methods[name] = fn;
      ref = schemas || this._schemas;
      for (key in ref) {
        schema = ref[key];
        schema.methods[name] = fn;
      }
      return this;
    };

    Mongo.prototype.loadStatic = function(name, fn, schemas) {
      var key, ref, schema;
      this._statics[name] = fn;
      ref = schemas || this._schemas;
      for (key in ref) {
        schema = ref[key];
        schema.statics[name] = fn;
      }
      return this;
    };

    Mongo.prototype.loadOverwrite = function(name, overwriteMethod, models) {
      this._overwrites[name] = overwriteMethod;
      Object.keys(models || this._models).forEach((function(_this) {
        return function(key) {
          var _origin, _overwriteMethod, model;
          model = _this._models[key];
          if (typeof model[name] !== 'function') {
            return;
          }
          _origin = model[name];
          _overwriteMethod = overwriteMethod(_origin);
          return model[name] = function() {
            return _overwriteMethod.apply(model, arguments);
          };
        };
      })(this));
      return this;
    };

    Mongo.prototype.loadSchema = function(modelName, schema) {
      var model, modelKey, newModels, newSchemas;
      modelKey = modelName.toLowerCase();
      this._schemas[modelKey] = schema;
      newSchemas = {};
      newSchemas[modelKey] = schema;
      this.loadMethods(this._methods, newSchemas);
      this.loadStatics(this._statics, newSchemas);
      model = this._conn.model(modelName, schema);
      newModels = {};
      newModels[modelKey] = model;
      this[modelKey] = model;
      this[modelName + 'Model'] = model;
      this._models[modelKey] = model;
      this.loadOverwrites(this._overwrites, newModels);
      if (this._rpcPort) {
        this.bindRpcEvent(modelKey);
      }
      return this;
    };

    Mongo.prototype.loadMethods = function(methods, schemas) {
      var fn, name;
      for (name in methods) {
        fn = methods[name];
        this.loadMethod(name, fn, schemas);
      }
      return this;
    };

    Mongo.prototype.loadStatics = function(statics, schemas) {
      var fn, name;
      for (name in statics) {
        fn = statics[name];
        this.loadStatic(name, fn, schemas);
      }
      return this;
    };

    Mongo.prototype.loadOverwrites = function(overwrites, models) {
      var fn, name;
      for (name in overwrites) {
        fn = overwrites[name];
        this.loadOverwrite(name, fn, models);
      }
      return this;
    };

    Mongo.prototype.loadSchemas = function(schemas) {
      var modelName, schema;
      for (modelName in schemas) {
        schema = schemas[modelName];
        this.loadSchema(modelName, schema);
      }
      return this;
    };

    Mongo.prototype.bindRpcEvent = function(modelKey) {
      var _bindMethod, group, ignoredMethods, method, methodName, model, models, self, server;
      server = this.getRpcServer();
      group = this._group;
      models = this._models;
      model = models[modelKey];
      self = this;
      _bindMethod = function(methodName) {
        var eventName;
        eventName = group + "." + modelKey + "." + methodName;
        return server.expose(eventName, function() {
          var _callback, _emit, callback, sock;
          sock = this;
          _emit = function() {
            var k, modelArgs, rpcEvents, v;
            modelArgs = (function() {
              var results;
              results = [];
              for (k in arguments) {
                v = arguments[k];
                results.push(v);
              }
              return results;
            }).apply(this, arguments);
            modelArgs.unshift(methodName);
            model.emit.apply(model, modelArgs);
            rpcEvents = Array.apply(null, arguments);
            rpcEvents.unshift('rpc', eventName, sock);
            return self.emit.apply(self, rpcEvents);
          };
          callback = arguments[arguments.length - 1];
          if (typeof callback === 'function') {
            _callback = (function(_this) {
              return function() {
                _emit.apply(_this, arguments);
                return callback.apply(_this, arguments);
              };
            })(this);
            arguments[arguments.length - 1] = _callback;
          } else {
            _callback = (function(_this) {
              return function() {
                return _emit.apply(_this, arguments);
              };
            })(this);
            arguments[arguments.length] = _callback;
          }
          return model[methodName].apply(model, arguments);
        });
      };
      ignoredMethods = ['constructor'];
      for (methodName in model) {
        method = model[methodName];
        if (!(typeof method === 'function' && methodName.indexOf('_') !== 0 && indexOf.call(ignoredMethods, methodName) < 0)) {
          continue;
        }
        _bindMethod(methodName);
      }
      return this;
    };

    Mongo.prototype.listen = function(options, callback) {
      var port;
      if (options == null) {
        options = {};
      }
      if (callback == null) {
        callback = function() {};
      }
      if (!this._rpcPort) {
        return;
      }
      port = Number(this._rpcPort);
      if (options.tls) {
        this.rpcServer.sock.set('tls', options.tls);
      }
      return this.rpcServer.sock.bind(port, callback);
    };

    return Mongo;

  })(EventEmitter);

  module.exports = Mongo;

}).call(this);
